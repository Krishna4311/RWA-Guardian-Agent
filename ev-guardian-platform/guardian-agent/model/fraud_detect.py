from flask import Flask, request, jsonify
from flask_cors import CORS
import pandas as pd
import numpy as np
import pickle
import os
import datetime
import threading
import time

# Imports for Cardano interaction (Mocking pycardano structure for demonstration)
# from pycardano import TransactionBuilder, Redeemer, PlutusData

app = Flask(__name__)
CORS(app)  # Enable CORS for frontend connection

class GuardianAgent:
    def __init__(self):
        # 1. Load the Trained Model
        model_path = os.path.join(os.path.dirname(__file__), "fraud_model.pkl")
        if os.path.exists(model_path):
            try:
                with open(model_path, "rb") as f:
                    self.model = pickle.load(f)
                print("‚úÖ Loaded Trained Fraud Model")
            except Exception as e:
                print(f"‚ö†Ô∏è Failed to load model: {e}")
                self.model = None
        else:
            self.model = None
            print("‚ö†Ô∏è Model not found, falling back to rule-based logic")

        # Physics Constants
        self.MIN_VOLTAGE = 200
        self.MAX_VOLTAGE = 260
        self.MAX_CURRENT = 50
        self.ENERGY_TOLERANCE = 0.05
        
        # Store latest reading for /ingest
        self.latest_reading = {
            "voltage": 230.0,
            "current": 10.0,
            "energy_kwh": 0.0,
            "timestamp": datetime.datetime.now().isoformat(),
            "status": "VALID",
            "reason": "Initializing..."
        }
        
        # Simulation State
        self.simulation_running = True
        self.dataset = []
        self.current_index = 0
        
        # Load Dataset
        self.load_dataset()
        
        # Start Simulation Thread
        self.sim_thread = threading.Thread(target=self.run_simulation, daemon=True)
        self.sim_thread.start()

    def load_dataset(self):
        # Try to load the CSV generated by generate_test_data.py
        # It is now located in the datasets folder
        possible_paths = [
            os.path.join(os.path.dirname(__file__), "../../datasets/test_ev_data.csv"),
            "../../datasets/test_ev_data.csv",
            "../datasets/test_ev_data.csv",
            "datasets/test_ev_data.csv"
        ]
        
        for path in possible_paths:
            if os.path.exists(path):
                try:
                    df = pd.read_csv(path)
                    self.dataset = df.to_dict('records')
                    print(f"‚úÖ Loaded simulation dataset from {path} ({len(self.dataset)} records)")
                    return
                except Exception as e:
                    print(f"‚ö†Ô∏è Failed to read CSV {path}: {e}")
        
        print("‚ö†Ô∏è No dataset found. Generating mock data on the fly.")
        self.dataset = []

    def run_simulation(self):
        print("üöÄ Starting Real-time Simulation Loop...")
        while self.simulation_running:
            if self.dataset:
                # Get current row
                row = self.dataset[self.current_index]
                
                # Check for fraud using the agent logic
                decision, reason = self.check_session(row)

                # Print status to terminal (Detailed Logging)
                timestamp = datetime.datetime.now().strftime("%H:%M:%S")
                if decision == "FRAUD":
                    print(f"[{timestamp}] üö® FRAUD DETECTED | Session: {row.get('session_id')} | Reason: {reason} | Value: {row.get('voltage')}V / {row.get('current')}A")
                    # Trigger on-chain defense
                    self.trigger_on_chain_defense(row.get('session_id'), decision, reason)
                else:
                    # Optional: Print valid frames too, but maybe less obtrusively
                    # print(f"[{timestamp}] ‚úÖ Valid | {row.get('voltage')}V | {row.get('current')}A")
                    pass
                
                # Update latest reading
                self.latest_reading = {
                    "voltage": float(row.get('voltage', 230)),
                    "current": float(row.get('current', 10)),
                    "energy_kwh": float(row.get('energy_kwh', 0)),
                    "timestamp": datetime.datetime.now().isoformat(),
                    "status": decision,
                    "reason": reason,
                    "session_id": row.get('session_id', 'Unknown'),
                    "time_index": row.get('time_index', 0)
                }
                
                # Move to next index (loop)
                self.current_index = (self.current_index + 1) % len(self.dataset)
            else:
                # Fallback if no dataset
                import random
                voltage = 230 + random.uniform(-2, 2)
                current = 10 + random.uniform(-0.5, 0.5)
                self.latest_reading = {
                    "voltage": voltage,
                    "current": current,
                    "energy_kwh": 0,
                    "timestamp": datetime.datetime.now().isoformat(),
                    "status": "VALID",
                    "reason": "Mock Data"
                }
            
            # Sleep for 1 second to simulate real-time
            time.sleep(1)

    def build_contract_redeemer(self, decision, reason):
        """
        Constructs the Aiken StatusUpdate Redeemer
        pub type StatusUpdate {
          new_status: ByteArray,
          decision_log_ref: ByteArray,
        }
        """
        # This represents the specific structure required by your .ak file
        # In a real pycardano script, you would map this to PlutusData
        redeemer = {
            "constructor": 0,
            "fields": [
                bytes(decision, "utf-8").hex(),  # new_status
                bytes(f"Log-{datetime.datetime.now().timestamp()}", "utf-8").hex() # decision_log_ref
            ]
        }
        return redeemer

    def trigger_on_chain_defense(self, session_id, decision, reason):
        """
        Simulates building the transaction to interact with atala_guard.ak
        """
        redeemer = self.build_contract_redeemer(decision, reason)
        
        print(f"üîó [Cardano] Building Tx for Session {session_id}")
        print(f"   - Validator: atala_guard.ak")
        print(f"   - Redeemer: {redeemer}")
        print(f"   - Action: {'üîí LOCK ASSETS' if decision == 'FRAUD' else '‚úÖ VERIFY SESSION'}")
        
        return "tx_hash_placeholder_12345"

    def check_session(self, current_reading):
        """
        Hybrid approach: Rules (Safety) + AI Model (Pattern)
        """
        # Handle both single dict and list of dicts (take the last one if list)
        if isinstance(current_reading, list):
            if not current_reading:
                return "VALID", "No data"
            # In a real scenario, we might analyze the whole sequence
            # For now, check the latest point
            data_point = current_reading[-1]
        else:
            data_point = current_reading

        voltage = float(data_point.get('voltage', 0))
        current = float(data_point.get('current', 0))
        energy = float(data_point.get('energy_kwh', 0))
        
        # --- Layer 1: Hard Safety Rules ---
        if voltage < self.MIN_VOLTAGE or voltage > self.MAX_VOLTAGE:
            return "FRAUD", f"Voltage anomaly: {voltage}V"
        if current > self.MAX_CURRENT:
            return "FRAUD", f"Current anomaly: {current}A"

        # --- Layer 2: Trained AI Model ---
        if self.model:
            # Prepare features exactly as trained in train_model.py
            # Note: Single point prediction usually needs context, 
            # here we approximate with instantaneous values for the demo
            try:
                features = pd.DataFrame([{
                    "max_voltage": voltage,
                    "min_voltage": voltage,
                    "mean_current": current,
                    "total_energy": energy,
                    "physics_diff": 0.0 # Simplified for real-time stream
                }])
                
                prediction = self.model.predict(features)[0]
                if prediction == 1:
                    return "FRAUD", "AI Model detected anomalous pattern"
            except Exception as e:
                print(f"Model prediction error: {e}")

        return "VALID", "Session normal"

guardian = GuardianAgent()

@app.route('/predict', methods=['POST'])
def predict():
    try:
        data = request.json
        session_id = data.get('session_id', 'Unknown')
        session_data = data.get('data', {})
        
        # Analyze
        decision, reason = guardian.check_session(session_data)
        
        # If Fraud, trigger contract logic
        tx_hash = None
        if decision == "FRAUD":
            tx_hash = guardian.trigger_on_chain_defense(session_id, decision, reason)

        return jsonify({
            "session_id": session_id,
            "status": decision,
            "reason": reason,
            "tx_hash": tx_hash,
            "timestamp": datetime.datetime.now().isoformat()
        })

    except Exception as e:
        print(f"Error: {e}")
        return jsonify({"status": "ERROR", "reason": str(e)}), 500

# Endpoint for the dashboard to ingest real-time data
@app.route('/ingest', methods=['GET'])
def ingest():
    return jsonify(guardian.latest_reading)

# Status endpoint for the polling hook
@app.route('/status', methods=['GET'])
def status():
    return jsonify({
        "status": guardian.latest_reading.get("status", "VALID"),
        "message": "System Online - Processing Stream",
        "timestamp": datetime.datetime.now().timestamp()
    })

if __name__ == "__main__":
    print("üß† Guardian AI Brain (Connected to Model & Aiken) running on port 5000...")
    app.run(host='0.0.0.0', port=5000, debug=True)